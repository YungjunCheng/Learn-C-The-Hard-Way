+ 弄清楚在for循环的每一部分你都可以放置什么样的代码。
C语言的for循环语法为：
```C
for (初始化; 条件; 递增) {
	// 代码
}
```

初始化部分：
可以声明变量（C99或更高支持声明多个变量）或执行表达式。
允许用逗号分隔多个语句：
```C
for (int i = 0, j = 10; ... ; ...)  // 合法（C99+）
```
条件部分：
必须是布尔表达式（结果为真或假）。
不能直接使用逗号分隔多个条件，但可以用逻辑运算符：
```C
for (; i < 10 && j > 0; ...)  // 合法
```

递增部分：
允许用逗号分隔多个表达式：
```C
for (... ; ... ; i++, j--)
```
+ 查询如何使用','（逗号）字符来在for循环的每一部分中，';'（分号）之间分隔多条语句。
逗号运算符允许在for循环的初始化和递增部分分隔多条语句：
```C
// 初始化部分声明两个变量并赋值
for (int i = 0, j = 10; i < j; i++, j--) {
	printf("%d vs %d\n", i, j);
}
```
注意：
条件部分不能使用逗号分隔多个条件，必须用逻辑运算符（如&&或||）。
逗号运算符会按顺序执行表达式，返回最后一个表达式的值（但条件部分通常不需要返回值）。

+ 查询NULL是什么东西，尝试将它用做states的一个元素，看看它会打印出什么。

若将NULL作为字符串数组的元素：
```C
char *states[] = {"California", NULL, "Washington"};
printf("state 1: %s\n", states[1]);  // 尝试打印NULL
```
结果：
大多数系统会输出(null)（如Linux的printf实现）。
某些严格环境下可能触发段错误（访问空指针）。
建议：
在打印前检查指针是否为空：
```C
if (states[i] != NULL) {
	printf("state %d: %s\n", i, states[i]);
}
```

+ 看看你是否能在打印之前将states的一个元素赋值给argv中的元素，再试试相反的操作。
将states元素赋值给argv：
```C
argv[0] = states[0];  // 合法，指针赋值
printf("argv[0]: %s\n", argv[0]);  // 输出"California"
```
这是安全的，因为只是修改指针的指向。

将argv元素赋值给states：
```C
states[0] = argv[1];  // 合法
printf("state 0: %s\n", states[0]);  // 输出命令行参数
```
危险操作：
```C
// 试图修改字符串字面量的内容（未定义行为）
states[0][0] = 'c';  // 可能崩溃，字符串字面量存储在只读内存
										 // 试图修改argv内容（实现定义行为）
argv[0][0] = '.';    // 可能崩溃，命令行参数可能存储在只读内存
```

